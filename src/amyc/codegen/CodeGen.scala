package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr, Nil)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = expr match {

      case Variable(name) => GetLocal(locals(name))
      case IntLiteral(value) => Const(value)
      case BooleanLiteral(value) => if(value) Const(1) else Const(0)
      case StringLiteral(value) => mkString(value)
      case UnitLiteral() => Const(0)
        
      case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
      case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
      case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
      case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div 
      case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
      case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
      case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
      case AmyAnd(lhs, rhs) =>
      cgExpr(lhs) <:> If_i32 <:> cgExpr(rhs) <:> Else <:> Const(0) <:> End
      case AmyOr(lhs, rhs) =>
      cgExpr(lhs) <:> If_i32 <:> Const(1) <:> Else <:> cgExpr(rhs) <:> End
      case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
      case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call("String_concat")
      
      case Not(e) => cgExpr(e) <:> Eqz
      case Neg(e) => Const(0) <:> cgExpr(e)  <:> Sub
        
      case AmyCall(qname, args, _) => table.getFunction(qname) match{
        case Some(funSig) => args.foldLeft(Code(Nil))((acc,el) => acc <:> cgExpr(el)) <:>
        Call(fullName(funSig.owner, qname))
        case None => //constructor call
          val index = table.getConstructor(qname).get.index
          val initialBoundary = lh.getFreshLocal()
          val newBoundary = lh.getFreshLocal()
          val writeArguments = for ((expr, ind) <- args.zipWithIndex.toList) yield {
          GetLocal(initialBoundary) <:> Const((ind + 1)*4) <:> Add <:>
          cgExpr(expr) <:> Store
          }
          //Save initial boundary
          GetGlobal(memoryBoundary) <:>
          SetLocal(initialBoundary) <:>
          //Compute new boundary
          GetLocal(initialBoundary) <:> 
          Const(4*(args.size + 1)) <:> 
          Add <:> 
          SetLocal(newBoundary) <:>
          //Advance stack pointer
          GetLocal(newBoundary) <:>
          SetGlobal(memoryBoundary)<:>
          //Write constructor index
          GetLocal(initialBoundary) <:>
          Const(index) <:> 
          Store <:> 
          writeArguments <:>
          GetLocal(initialBoundary)
      }
      case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)
      case Let(df, value, body) => val id = lh.getFreshLocal()
      cgExpr(value) <:> SetLocal(id) <:> cgExpr(body)(locals + (df.name -> id), lh)
      case Ite(cond, thenn, elze) => cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End
      
      case Match(scrut, cases) => 
        
        def matchAndBind(p : Pattern, valueToCompare : Code, idToBind : Int) : (Code, Map[Identifier, Int]) = p match {
          case WildcardPattern() => (Const(1), Map())
          case IdPattern(name) => (valueToCompare <:> Drop <:> Const(1), Map(name -> idToBind))
          case LiteralPattern(lit) => (cgExpr(lit) <:> valueToCompare <:> Eq, Map())
          case CaseClassPattern(constr, args) => 
            val index = table.getConstructor(constr).get.index
            val constrType = valueToCompare <:> Load <:> Const(index) <:> Eq 
            args.zipWithIndex.foldLeft((constrType, Map()): (Code, Map[Identifier, Int]))({
              (acc, el) =>
                val newLocal = lh.getFreshLocal()
                val arg = matchAndBind(el._1, 
                    valueToCompare <:> Const((el._2 + 1)*4) <:> Add <:> Load <:> SetLocal(newLocal) <:> GetLocal(newLocal), 
                    newLocal)
                (acc._1 <:> arg._1 <:> And, acc._2 ++ arg._2)
            })
        }
        
        def addEnd(i : Int) : Code = if(i == 0) Code(Nil) else addEnd(i-1) <:> End
        
        val scrutLocal = lh.getFreshLocal()
        val patternMatching = cases.foldLeft(cgExpr(scrut) <:> SetLocal(scrutLocal))({
          (acc, el) => 
            val (code, newLocals) = matchAndBind(el.pat, GetLocal(scrutLocal), scrutLocal)
            acc <:> code <:> If_i32 <:> cgExpr(el.expr)(locals ++ newLocals, lh) <:> Else 
        }) <:> 
        Unreachable
        
        patternMatching <:> addEnd(cases.size)
      case Error(msg) => cgExpr(msg) <:> Call("Std_printString") <:> Unreachable
        
    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}

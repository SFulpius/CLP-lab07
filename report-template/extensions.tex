When we use polymorphic types, we always require to specify the types. This is easier to write a compiler with this restriction, but in general we don't always need it. For example, when we instantiate a case class, we write :
\begin{lstlisting}
val x : List[Int] = Nil[Int]()
\end{lstlisting}
We could easily infer the types : the case class must have the same types as its parent class. We already do this in the pattern matching, and we could also do this in general.

In some case we could even infer the type of the parent class. We could for instance write:
\begin{lstlisting}
val x : List = Cons(2, Nil())
\end{lstlisting}
Then by looking at the types in the case class, we could know that this is a list of Int. Although this will not work in all cases. If we write: 
\begin{lstlisting}
val x : List = Nil()
\end{lstlisting}
then we don't have enough information to determine the type of the list.
